import { AssetEmitter, Context, EmittedSourceFile, EmitterOutput, Scope, SourceFile } from "@typespec/asset-emitter";
import { Model } from "@typespec/compiler";
import { HttpStatusCodeRange } from "@typespec/http";
import { HttpRequestParameterKind } from "@typespec/http/experimental/typekit";
import { CSharpServiceEmitterOptions } from "./lib.js";
export declare const HelperNamespace: string;
export interface CSharpTypeMetadata {
    name: string;
    namespace?: string;
}
export interface ResponseInfo {
    statusCode: number | HttpStatusCodeRange | "*";
    csharpStatusCode: string;
    resultType: CSharpType;
}
export declare class CSharpType implements CSharpTypeMetadata {
    name: string;
    namespace: string;
    isBuiltIn: boolean;
    isValueType: boolean;
    isNullable: boolean;
    isClass: boolean;
    isCollection: boolean;
    constructor(input: {
        name: string;
        namespace: string;
        isBuiltIn?: boolean;
        isValueType?: boolean;
        isNullable?: boolean;
        isClass?: boolean;
        isCollection?: boolean;
    });
    isNamespaceInScope(scope?: Scope<string>, visited?: Set<Scope<string>>): boolean;
    getTypeReference(scope?: Scope<string>): string;
    equals(other: CSharpType | undefined): boolean;
}
export declare function checkOrAddNamespaceToScope(ns: string, scope?: Scope<string>, visited?: Set<Scope<string>>): boolean;
export declare enum CollectionType {
    ISet = "ISet",
    ICollection = "ICollection",
    IEnumerable = "IEnumerable",
    Array = "[]"
}
export declare function resolveCollectionType(option?: string): CollectionType;
export declare class CSharpCollectionType extends CSharpType {
    collectionType: CollectionType;
    itemTypeName: string;
    static readonly implementationType: Record<CollectionType, string>;
    constructor(csharpType: {
        name: string;
        namespace: string;
        isBuiltIn?: boolean;
        isValueType?: boolean;
        isNullable?: boolean;
        isClass?: boolean;
        isCollection?: boolean;
    }, collectionType: CollectionType, itemTypeName: string);
    getTypeReference(scope?: Scope<string> | undefined): string;
    getImplementationType(): string;
}
export declare abstract class CSharpValue {
    value?: any;
    abstract emitValue(scope?: Scope<string>): string;
}
export declare class StringValue extends CSharpValue {
    value?: string;
    constructor(value?: string);
    emitValue(scope?: Scope<string> | undefined): string;
}
export declare class RawValue extends CSharpValue {
    value?: string;
    constructor(value?: string);
    emitValue(scope?: Scope<string> | undefined): string;
}
export declare class NumericValue extends CSharpValue {
    value?: number;
    constructor(value?: number);
    emitValue(scope?: Scope<string> | undefined): string;
}
export declare class BooleanValue extends CSharpValue {
    value?: boolean;
    constructor(value?: boolean);
    emitValue(scope?: Scope<string> | undefined): string;
}
export declare class NullValue extends CSharpValue {
    value?: null;
    emitValue(scope?: Scope<string> | undefined): string;
}
export declare class Parameter implements CSharpTypeMetadata {
    type: CSharpType;
    optional: boolean;
    name: string;
    value?: CSharpValue;
    defaultValue?: CSharpValue;
    constructor(input: {
        name: string;
        type: CSharpType;
        optional: boolean;
        value?: CSharpValue;
        defaultValue?: CSharpValue;
    });
    getDeclarationString(scope?: Scope<string>): string;
    getCallString(scope?: Scope<string>): string;
}
export declare class AttributeType extends CSharpType {
    getTypeReference(scope?: Scope<string> | undefined): string;
}
export declare class Attribute {
    type: AttributeType;
    parameters: Parameter[];
    constructor(type: AttributeType, parameters?: Parameter[]);
    getApplicationString(scope?: Scope<string>): string;
}
export declare abstract class CSharpDeclaration {
    type: CSharpType;
    emitter: AssetEmitter<string, Record<string, never>>;
    abstract getDeclaration(scope: Scope<string>): EmitterOutput<string>;
    constructor(type: CSharpType, emitter: AssetEmitter<string, Record<string, never>>);
}
export declare class CSharpModel extends CSharpDeclaration {
    constructor(modelName: string, modelNamespace: string, emitter: AssetEmitter<string, Record<string, never>>);
    properties: Parameter[];
    getDeclaration(scope: Scope<string>): EmitterOutput<string>;
}
export declare class CSharpEnum extends CSharpDeclaration {
    getDeclaration(scope: Scope<string>): EmitterOutput<string>;
}
export declare class CSharpController extends CSharpDeclaration {
    getDeclaration(scope: Scope<string>): EmitterOutput<string>;
}
export interface ControllerContext extends Context {
    namespace: string;
    resourceName: string;
    resourceType?: Model;
    scope: Scope<string>;
}
export interface ModelContext extends Context {
    file: SourceFile<string>;
    scope: Scope<string>;
    usedNamespaces: Set<string>;
}
export declare enum CSharpSourceType {
    Model = 0,
    Controller = 1,
    RouteConstants = 2,
    Interface = 3
}
export declare enum NameCasingType {
    Class = 0,
    Constant = 1,
    Method = 2,
    Namespace = 3,
    Parameter = 4,
    Property = 5,
    Variable = 6
}
export declare class LibrarySourceFile {
    constructor(params: {
        filename: string;
        getContents: () => string;
        emitter: AssetEmitter<string, CSharpServiceEmitterOptions>;
        path?: string;
        conditional?: boolean;
    });
    conditional: boolean;
    filename: string;
    source: SourceFile<string>;
    emitted: EmittedSourceFile;
    path: string;
}
export interface CSharpOperationParameter {
    name: string;
    typeName: EmitterOutput<string>;
    optional: boolean;
    httpParameterKind: HttpRequestParameterKind;
    httpParameterName?: string;
    callName: string;
    isExplicitBody: boolean;
    nullable: boolean;
    operationKind: "Http" | "BusinessLogic" | "All";
    defaultValue?: string | boolean;
}
//# sourceMappingURL=interfaces.d.ts.map