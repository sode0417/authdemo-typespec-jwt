export const HelperNamespace = "TypeSpec.Helpers.JsonConverters";
export class CSharpType {
    name;
    namespace;
    isBuiltIn;
    isValueType;
    isNullable;
    isClass;
    isCollection;
    constructor(input) {
        this.name = input.name;
        this.namespace = input.namespace;
        this.isBuiltIn = input.isBuiltIn !== undefined ? input.isBuiltIn : input.namespace === "System";
        this.isValueType = input.isValueType !== undefined ? input.isValueType : false;
        this.isNullable = input.isNullable !== undefined ? input.isNullable : false;
        this.isClass = input.isClass !== undefined ? input.isClass : false;
        this.isCollection = input.isCollection !== undefined ? input.isCollection : false;
    }
    isNamespaceInScope(scope, visited) {
        if (this.isBuiltIn)
            return true;
        return checkOrAddNamespaceToScope(this.namespace, scope, visited);
    }
    getTypeReference(scope) {
        return this.isNamespaceInScope(scope) ? this.name : `${this.namespace}.${this.name}`;
    }
    equals(other) {
        return this.name === other?.name && this.namespace === other?.namespace;
    }
}
export function checkOrAddNamespaceToScope(ns, scope, visited) {
    if (!ns)
        return false;
    if (scope === undefined)
        return false;
    if (!visited)
        visited = new Set();
    if (visited.has(scope))
        return false;
    visited.add(scope);
    switch (scope.kind) {
        case "namespace": {
            if (scope.namespace.startsWith(ns))
                return true;
            return checkOrAddNamespaceToScope(ns, scope.parentScope, visited);
        }
        case "sourceFile": {
            const fileNameSpace = scope.sourceFile.meta["ResolvedNamespace"];
            if (fileNameSpace && fileNameSpace.startsWith(ns))
                return true;
            for (const entry of scope.sourceFile.imports.keys()) {
                if (entry === ns) {
                    return true;
                }
            }
            const added = scope.sourceFile.meta["AddedScope"];
            if (added === undefined) {
                scope.sourceFile.imports.set(ns, [ns]);
                scope.sourceFile.meta["AddedScope"] = ns;
                return true;
            }
            return false;
        }
        default:
            return false;
    }
}
export var CollectionType;
(function (CollectionType) {
    CollectionType["ISet"] = "ISet";
    CollectionType["ICollection"] = "ICollection";
    CollectionType["IEnumerable"] = "IEnumerable";
    CollectionType["Array"] = "[]";
})(CollectionType || (CollectionType = {}));
export function resolveCollectionType(option) {
    switch (option) {
        case "enumerable":
            return CollectionType.IEnumerable;
        case "array":
        default:
            return CollectionType.Array;
    }
}
export class CSharpCollectionType extends CSharpType {
    collectionType;
    itemTypeName;
    static implementationType = {
        [CollectionType.ISet]: "HashSet",
        [CollectionType.ICollection]: "List",
        [CollectionType.IEnumerable]: "List",
        [CollectionType.Array]: "[]",
    };
    constructor(csharpType, collectionType, itemTypeName) {
        super(csharpType);
        this.collectionType = collectionType;
        this.itemTypeName = itemTypeName;
    }
    getTypeReference(scope) {
        if (this.isNamespaceInScope(scope)) {
            return this.name;
        }
        return `${this.collectionType}<${this.namespace}.${this.itemTypeName}>`;
    }
    getImplementationType() {
        switch (this.collectionType) {
            case CollectionType.ISet:
            case CollectionType.ICollection:
            case CollectionType.IEnumerable:
                return `new ${CSharpCollectionType.implementationType[this.collectionType]}<${this.itemTypeName}>()`;
            default:
                return `[]`;
        }
    }
}
export class CSharpValue {
    value;
}
export class StringValue extends CSharpValue {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    emitValue(scope) {
        return `"${this.value}"`;
    }
}
export class RawValue extends CSharpValue {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    emitValue(scope) {
        return `${this.value}`;
    }
}
export class NumericValue extends CSharpValue {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    emitValue(scope) {
        return `${this.value ?? 0}`;
    }
}
export class BooleanValue extends CSharpValue {
    value;
    constructor(value) {
        super();
        this.value = value;
    }
    emitValue(scope) {
        return `${this.value}`;
    }
}
export class NullValue extends CSharpValue {
    value = null;
    emitValue(scope) {
        return "null";
    }
}
export class Parameter {
    type;
    optional;
    name;
    value;
    defaultValue;
    constructor(input) {
        this.name = input.name;
        this.type = input.type;
        this.optional = input.optional;
        this.value = input.value;
        this.defaultValue = input.defaultValue;
    }
    getDeclarationString(scope) {
        const sb = [];
        sb.push(`${this.type.getTypeReference(scope)}`);
        if (this.optional)
            sb.push("?");
        sb.push(` ${this.name}`);
        if (this.defaultValue !== undefined)
            sb.push(` = ${this.defaultValue.emitValue(scope)}`);
        return sb.join(", ");
    }
    getCallString(scope) {
        if (!this.value)
            return "";
        const sb = [];
        if (this.optional)
            sb.push(`${this.name} = ${this.value.emitValue(scope)}`);
        else
            sb.push(this.value.emitValue(scope));
        return sb.join(", ");
    }
}
export class AttributeType extends CSharpType {
    getTypeReference(scope) {
        const ref = super.getTypeReference(scope);
        const suffixStart = ref.lastIndexOf("Attribute");
        if (suffixStart < 1)
            return ref;
        return ref.slice(0, suffixStart);
    }
}
export class Attribute {
    type;
    parameters;
    constructor(type, parameters) {
        this.type = type;
        this.parameters = parameters === undefined ? [] : parameters;
    }
    getApplicationString(scope) {
        const sb = [];
        const parameters = [];
        sb.push(`[${this.type.getTypeReference(scope)}`);
        for (let i = 0; i < this.parameters.length; ++i) {
            parameters.push(this.parameters[i].getCallString(scope));
        }
        if (parameters.length > 0)
            sb.push(`( ${parameters.join(", ")})`);
        sb.push("]");
        return sb.join("");
    }
}
export class CSharpDeclaration {
    type;
    emitter;
    constructor(type, emitter) {
        this.type = type;
        this.emitter = emitter;
    }
}
export class CSharpModel extends CSharpDeclaration {
    constructor(modelName, modelNamespace, emitter) {
        super(new CSharpType({
            name: modelName,
            namespace: modelNamespace,
            isBuiltIn: false,
            isValueType: false,
        }), emitter);
    }
    properties = [];
    getDeclaration(scope) {
        return "";
    }
}
export class CSharpEnum extends CSharpDeclaration {
    getDeclaration(scope) {
        return "";
    }
}
export class CSharpController extends CSharpDeclaration {
    getDeclaration(scope) {
        return "";
    }
}
export var CSharpSourceType;
(function (CSharpSourceType) {
    CSharpSourceType[CSharpSourceType["Model"] = 0] = "Model";
    CSharpSourceType[CSharpSourceType["Controller"] = 1] = "Controller";
    CSharpSourceType[CSharpSourceType["RouteConstants"] = 2] = "RouteConstants";
    CSharpSourceType[CSharpSourceType["Interface"] = 3] = "Interface";
})(CSharpSourceType || (CSharpSourceType = {}));
export var NameCasingType;
(function (NameCasingType) {
    NameCasingType[NameCasingType["Class"] = 0] = "Class";
    NameCasingType[NameCasingType["Constant"] = 1] = "Constant";
    NameCasingType[NameCasingType["Method"] = 2] = "Method";
    NameCasingType[NameCasingType["Namespace"] = 3] = "Namespace";
    NameCasingType[NameCasingType["Parameter"] = 4] = "Parameter";
    NameCasingType[NameCasingType["Property"] = 5] = "Property";
    NameCasingType[NameCasingType["Variable"] = 6] = "Variable";
})(NameCasingType || (NameCasingType = {}));
export class LibrarySourceFile {
    constructor(params) {
        this.path = params.path || "generated/lib/";
        this.filename = params.filename;
        const source = params.emitter.createSourceFile(`${this.path}/${this.filename}`);
        this.conditional = params.conditional || false;
        this.emitted = {
            path: source.path,
            contents: params.getContents(),
        };
        source.meta = { emitted: this.emitted, conditional: this.conditional };
        this.source = source;
    }
    conditional;
    filename;
    source;
    emitted;
    path;
}
//# sourceMappingURL=interfaces.js.map