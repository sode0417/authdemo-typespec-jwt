import { CollectionType } from "./interfaces.js";
export interface CSharpServiceEmitterOptions {
    /**Skip formatting of output. Default is false (generated c-sharp files are formatted) */
    "skip-format"?: boolean;
    /** Choose which service artifacts to emit.  Default is 'all'.*/
    "output-type"?: "models" | "all";
    /** Emit mock implementations of business logic, setup code, and project files. Allows the service to respond to requests with mock responses.*/
    "emit-mocks"?: "none" | "mocks-only" | "mocks-and-project-files";
    /** Configure a Swagger UI endpoint in the development configuration. */
    "use-swaggerui"?: boolean;
    /** Use openapi at the given path for generating SwaggerUI endpoints. By default, this will be 'openapi/openapi.yaml' if the 'use-swaggerui' option is enabled. */
    "openapi-path"?: string;
    /** When generating mock files, overwrite any existing files with the same name. */
    overwrite?: boolean;
    /** The generated project name. */
    "project-name"?: string;
    /** The http port number to use when hosting the service locally */
    "http-port"?: number;
    /** The https port number to use when hosting the service locally */
    "https-port"?: number;
    /** Specifies the collection type to use: 'array' or 'enumerable'. The default is 'enumerable'." */
    "collection-type"?: "array" | "enumerable";
}
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "invalid-identifier": {
        readonly default: import("@typespec/compiler").CallableMessage<["identifier", "location"]>;
    };
    "anonymous-model": {
        readonly default: import("@typespec/compiler").CallableMessage<["emittedName"]>;
    };
    "missing-type-parent": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "name"]>;
    };
    "no-numeric": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "targetType"]>;
    };
    "unrecognized-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-intrinsic": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-interpolation": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "get-request-body": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
}, CSharpServiceEmitterOptions, never>;
export declare const reportDiagnostic: <C extends "invalid-identifier" | "anonymous-model" | "missing-type-parent" | "no-numeric" | "unrecognized-scalar" | "invalid-intrinsic" | "invalid-interpolation" | "get-request-body", M extends keyof {
    "invalid-identifier": {
        readonly default: import("@typespec/compiler").CallableMessage<["identifier", "location"]>;
    };
    "anonymous-model": {
        readonly default: import("@typespec/compiler").CallableMessage<["emittedName"]>;
    };
    "missing-type-parent": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "name"]>;
    };
    "no-numeric": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "targetType"]>;
    };
    "unrecognized-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-intrinsic": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-interpolation": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "get-request-body": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "invalid-identifier": {
        readonly default: import("@typespec/compiler").CallableMessage<["identifier", "location"]>;
    };
    "anonymous-model": {
        readonly default: import("@typespec/compiler").CallableMessage<["emittedName"]>;
    };
    "missing-type-parent": {
        readonly default: import("@typespec/compiler").CallableMessage<["type", "name"]>;
    };
    "no-numeric": {
        readonly default: import("@typespec/compiler").CallableMessage<["sourceType", "targetType"]>;
    };
    "unrecognized-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-intrinsic": {
        readonly default: import("@typespec/compiler").CallableMessage<["typeName"]>;
    };
    "invalid-interpolation": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
    "get-request-body": {
        readonly default: import("@typespec/compiler").CallableMessage<[]>;
    };
}, C, M>) => void, createStateSymbol: (name: string) => symbol, getTracer: (program: import("@typespec/compiler").Program) => import("@typespec/compiler").Tracer;
export type CSharpServiceLibrary = typeof $lib;
export declare class CSharpServiceOptions {
    private static instance;
    collectionType: CollectionType;
    private constructor();
    static getInstance(): CSharpServiceOptions;
    initialize(options: {
        "collection-type"?: string;
    }): void;
}
//# sourceMappingURL=lib.d.ts.map