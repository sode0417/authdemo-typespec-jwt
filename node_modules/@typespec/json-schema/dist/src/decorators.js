import { isType, serializeValueAsJson, setTypeSpecNamespace, typespecTypeToJson, } from "@typespec/compiler";
import { useStateMap, useStateSet } from "@typespec/compiler/utils";
import { JsonSchemaStateKeys } from "./lib.js";
import { createDataDecorator } from "./utils.js";
export const [
/** Check if the given type is annotated with `@jsonSchema`  */
getJsonSchema, markJsonSchema,] = useStateSet(JsonSchemaStateKeys.JsonSchema);
/** {@inheritdoc JsonSchemaDecorator} */
export const $jsonSchema = (context, target, baseUriOrId) => {
    markJsonSchema(context.program, target);
    if (baseUriOrId) {
        if (target.kind === "Namespace") {
            context.call($baseUri, target, baseUriOrId);
        }
        else {
            context.call($id, target, baseUriOrId);
        }
    }
};
export const [
/** Get base uri set via `@baseUri` decorator */
getBaseUri, setBaseUri, 
/** {@inheritdoc BaseUriDecorator} */
$baseUri,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.baseURI"]);
/** Find base uri for the given type. */
export function findBaseUri(program, target) {
    let baseUrl;
    let current = target;
    do {
        baseUrl = getBaseUri(program, current);
        current = current.namespace;
    } while (!baseUrl && current);
    return baseUrl;
}
/**
 * Check if the given type is annoted with `@jsonSchema` or within a container annoted with `@jsonSchema`.
 * @param program TypeSpec program
 * @param target Type
 */
export function isJsonSchemaDeclaration(program, target) {
    let current = target;
    do {
        if (getJsonSchema(program, current)) {
            return true;
        }
        current = current.namespace;
    } while (current);
    return false;
}
/**
 * Returns types that are annotated with `@jsonSchema` or contained within a namespace that is annoted with `@jsonSchema`.
 * @param program TypeSpec program
 */
export function getJsonSchemaTypes(program) {
    const types = [];
    function visitNamespace(ns) {
        if (getJsonSchema(program, ns)) {
            types.push(ns);
        }
        for (const member of ns.models.values()) {
            visitModel(member);
        }
        for (const member of ns.namespaces.values()) {
            visitNamespace(member);
        }
    }
    function visitModel(model) {
        if (isJsonSchemaDeclaration(program, model)) {
            types.push(model);
        }
    }
    visitNamespace(program.getGlobalNamespaceType());
    return types;
}
export const [
/** Get value set by `@multipleOf` decorator as a `Numeric` type. */
getMultipleOfAsNumeric, setMultipleOf, 
/** {@inheritdoc MultipleOfDecorator} */
$multipleOf,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.multipleOf"]);
/** Get value set by `@multipleOf` decorator as a `number` type. If the value is not representable as a number or not set, returns undefined. */
export function getMultipleOf(program, target) {
    return getMultipleOfAsNumeric(program, target)?.asNumber() ?? undefined;
}
export const [
/** Get id as set with `@id` decorator. */
getId, setId, 
/** {@inheritdoc IdDecorator} */
$id,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.id"]);
export const [
/** Check if given type is annotated with `@oneOf` decorator */
isOneOf, markOneOf,] = useStateSet(JsonSchemaStateKeys["JsonSchema.oneOf"]);
/** {@inheritdoc OneOfDecorator} */
export const $oneOf = (context, target) => {
    markOneOf(context.program, target);
};
export const [
/** Get contains value set by `@contains` decorator */
getContains, setContains, 
/** {@inheritdoc ContainsDecorator} */
$contains,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.contains"]);
export const [
/** Get value set by `@minContains` decorator */
getMinContains, setMinContains, 
/** {@inheritdoc MinContainsDecorator} */
$minContains,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.minContains"]);
export const [
/** Get value set by `@maxContains` decorator */
getMaxContains, setMaxContains, 
/** {@inheritdoc MaxContainsDecorator} */
$maxContains,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.maxContains"]);
export const [
/** Check if the given array is annotated with `@uniqueItems` decorator */
getUniqueItems, setUniqueItems,] = useStateMap(JsonSchemaStateKeys["JsonSchema.uniqueItems"]);
/** {@inheritdoc UniqueItemsDecorator} */
export const $uniqueItems = (context, target) => setUniqueItems(context.program, target, true);
export const [
/** Get minimum number of properties set by `@minProperties` decorator */
getMinProperties, setMinProperties, 
/** {@inheritdoc MinPropertiesDecorator} */
$minProperties,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.minProperties"]);
export const [
/** Get maximum number of properties set by `@maxProperties` decorator */
getMaxProperties, setMaxProperties, 
/** {@inheritdoc MaxPropertiesDecorator} */
$maxProperties,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.maxProperties"]);
export const [
/** Get content encoding as configured by `@contentEncoding` decorator. */
getContentEncoding, setContentEncoding, 
/** {@inheritdoc ContentEncodingDecorator} */
$contentEncoding,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.contentEncoding"]);
export const [
/** Get content media type as configured by `@contentMediaType` decorator. */
getContentMediaType, setContentMediaType, 
/** {@inheritdoc ContentMediaTypeDecorator} */
$contentMediaType,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.contentMediaType"]);
export const [
/** Get content schema set with `@contentSchema` decorator */
getContentSchema, setContentSchema, 
/** {@inheritdoc ContentSchemaDecorator} */
$contentSchema,] = createDataDecorator(JsonSchemaStateKeys["JsonSchema.contentSchema"]);
export const [
/** Get prefix items set with `@prefixItems` decorator */
getPrefixItems, setPrefixItems,] = useStateMap(JsonSchemaStateKeys["JsonSchema.prefixItems"]);
/** {@inheritdoc PrefixItemsDecorator} */
export const $prefixItems = (context, target, value) => {
    setPrefixItems(context.program, target, value); // This cast is incorrect and would cause a crash https://github.com/microsoft/typespec/issues/4742
};
const [getExtensionsInternal, _, getExtensionsStateMap] = useStateMap(JsonSchemaStateKeys["JsonSchema.extension"]);
/** {@inheritdoc ExtensionDecorator} */
export const $extension = (context, target, key, value) => {
    if (!isTypeLike(value)) {
        value = convertRemainingValuesToExtensions(context.program, value);
    }
    setExtension(context.program, target, key, value);
};
// Workaround until we have a way to disable arg marshalling and just call serializeValueAsJson
// https://github.com/microsoft/typespec/issues/3570
function convertRemainingValuesToExtensions(program, value) {
    switch (typeof value) {
        case "string":
        case "number":
        case "boolean":
            return value;
        case "object":
            if (value === null) {
                return null;
            }
            if (Array.isArray(value)) {
                return value.map((x) => convertRemainingValuesToExtensions(program, x));
            }
            if (isTypeSpecValue(value)) {
                return serializeValueAsJson(program, value, value.type);
            }
            else {
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    if (val === undefined) {
                        continue;
                    }
                    result[key] = convertRemainingValuesToExtensions(program, val);
                }
                return result;
            }
        default:
            return value;
    }
}
function isTypeLike(value) {
    return typeof value === "object" && value !== null && isType(value);
}
function isTypeSpecValue(value) {
    return "entityKind" in value && value.entityKind === "Value";
}
/**
 * Get extensions set via the `@extension` decorator on the given type
 * @param program TypeSpec program
 * @param target Type
 */
export function getExtensions(program, target) {
    return getExtensionsInternal(program, target) ?? [];
}
/**
 * Set extension on the given type(Same as calling `@extension` decorator)
 * @param program TypeSpec program
 * @param target Type
 * @param key Extension key
 * @param value Extension value
 */
export function setExtension(program, target, key, value) {
    const stateMap = getExtensionsStateMap(program);
    const extensions = stateMap.has(target)
        ? stateMap.get(target)
        : stateMap.set(target, []).get(target);
    // Check if we were handed the `Json` template model
    if (isJsonTemplateType(value)) {
        extensions.push({
            key,
            value: typespecTypeToJson(value.properties.get("value").type, target)[0],
        });
    }
    else {
        extensions.push({ key, value });
    }
}
function isJsonTemplateType(value) {
    return (typeof value === "object" &&
        value !== null &&
        isType(value) &&
        value.kind === "Model" &&
        value.name === "Json" &&
        value.namespace?.name === "JsonSchema");
}
/** @internal */
export const $validatesRawJson = (context, target, value) => {
    const [_, diagnostics] = typespecTypeToJson(value, target);
    if (diagnostics.length > 0) {
        context.program.reportDiagnostics(diagnostics);
    }
};
setTypeSpecNamespace("Private", $validatesRawJson);
//# sourceMappingURL=decorators.js.map