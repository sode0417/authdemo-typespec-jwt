import { type JSONSchemaType } from "@typespec/compiler";
/**
 * File type
 */
export type FileType = "yaml" | "json";
/**
 * Strategy for handling the int64 type in the resulting json schema.
 * - string: As a string
 * - number: As a number (In JavaScript, int64 cannot be accurately represented as number)
 *
 */
export type Int64Strategy = "string" | "number";
/**
 * Json schema emitter options
 */
export interface JSONSchemaEmitterOptions {
    /**
     * Serialize the schema as either yaml or json.
     * @defaultValue yaml it not specified infer from the `output-file` extension
     */
    "file-type"?: FileType;
    /**
     * How to handle 64-bit integers on the wire. Options are:
     *
     * - string: Serialize as a string (widely interoperable)
     * - number: Serialize as a number (not widely interoperable)
     */
    "int64-strategy"?: Int64Strategy;
    /**
     * When provided, bundle all the schemas into a single JSON Schema document
     * with schemas under $defs. The provided id is the id of the root document
     * and is also used for the file name.
     */
    bundleId?: string;
    /**
     * When true, emit all model declarations to JSON Schema without requiring
     * the `@jsonSchema` decorator.
     */
    emitAllModels?: boolean;
    /**
     * When true, emit all references as JSON Schema files, even if the referenced
     * type does not have the `@jsonSchema` decorator or is not within a namespace
     * with the `@jsonSchema` decorator.
     */
    emitAllRefs?: boolean;
    /**
     * If true, then for models emitted as object schemas we default `unevaluatedProperties` to `{ not: {} }`,
     * if not explicitly specified elsewhere.
     * @defaultValue false
     */
    "seal-object-schemas"?: boolean;
}
/**
 * Internal: Json Schema emitter options schema
 */
export declare const EmitterOptionsSchema: JSONSchemaType<JSONSchemaEmitterOptions>;
/** Internal: TypeSpec library definition */
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "duplicate-id": {
        readonly default: import("@typespec/compiler").CallableMessage<["id"]>;
    };
    "unknown-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
}, JSONSchemaEmitterOptions, "JsonSchema" | "JsonSchema.baseURI" | "JsonSchema.multipleOf" | "JsonSchema.id" | "JsonSchema.oneOf" | "JsonSchema.contains" | "JsonSchema.minContains" | "JsonSchema.maxContains" | "JsonSchema.uniqueItems" | "JsonSchema.minProperties" | "JsonSchema.maxProperties" | "JsonSchema.contentEncoding" | "JsonSchema.contentSchema" | "JsonSchema.contentMediaType" | "JsonSchema.prefixItems" | "JsonSchema.extension">;
/** Internal: TypeSpec flags */
export declare const $flags: import("@typespec/compiler").PackageFlags;
export declare const reportDiagnostic: <C extends "invalid-default" | "duplicate-id" | "unknown-scalar", M extends keyof {
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "duplicate-id": {
        readonly default: import("@typespec/compiler").CallableMessage<["id"]>;
    };
    "unknown-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "invalid-default": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "duplicate-id": {
        readonly default: import("@typespec/compiler").CallableMessage<["id"]>;
    };
    "unknown-scalar": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
}, C, M>) => void, createStateSymbol: (name: string) => symbol, JsonSchemaStateKeys: Record<"JsonSchema" | "JsonSchema.baseURI" | "JsonSchema.multipleOf" | "JsonSchema.id" | "JsonSchema.oneOf" | "JsonSchema.contains" | "JsonSchema.minContains" | "JsonSchema.maxContains" | "JsonSchema.uniqueItems" | "JsonSchema.minProperties" | "JsonSchema.maxProperties" | "JsonSchema.contentEncoding" | "JsonSchema.contentSchema" | "JsonSchema.contentMediaType" | "JsonSchema.prefixItems" | "JsonSchema.extension", symbol>;
export type JsonSchemaLibrary = typeof $lib;
//# sourceMappingURL=lib.d.ts.map