import { generateDocs } from "../utils/docs.js";
import { generateDecorators } from "./generate-decorators.js";
import { generateOperationReturnType } from "./generate-response-expressions.js";
export function generateOperation(operation, context) {
    const definitions = [];
    if (operation.doc) {
        definitions.push(generateDocs(operation.doc));
    }
    definitions.push(...operation.tags.map((t) => `@tag("${t}")`));
    definitions.push(generateDecorators(operation.decorators).join(" "));
    // generate parameters
    const parameters = [
        ...operation.parameters.map((p) => generateOperationParameter(operation, p, context)),
        ...generateRequestBodyParameters(operation.requestBodies, context),
    ];
    const responses = generateOperationReturnType(operation, context);
    definitions.push(`op ${operation.name}(${parameters.join(", ")}): ${responses};`);
    return definitions.join(" ");
}
function generateOperationParameter(operation, parameter, context) {
    if ("$ref" in parameter) {
        return `...${context.getRefName(parameter.$ref, operation.scope)}`;
    }
    const definitions = [];
    if (parameter.doc) {
        definitions.push(generateDocs(parameter.doc));
    }
    definitions.push(...generateDecorators(parameter.decorators));
    definitions.push(`${parameter.name}${parameter.isOptional ? "?" : ""}: ${context.generateTypeFromRefableSchema(parameter.schema, operation.scope)}`);
    return definitions.join(" ");
}
function generateRequestBodyParameters(requestBodies, context) {
    if (!requestBodies.length) {
        return [];
    }
    const definitions = [];
    // Generate the content-type header if defined content-types is not just 'application/json'
    const contentTypes = requestBodies.map((r) => r.contentType);
    if (!supportsOnlyJson(contentTypes)) {
        definitions.push(`@header contentType: ${contentTypes.map((c) => `"${c}"`).join(" | ")}`);
    }
    // Get the set of referenced types
    const body = Array.from(new Set(requestBodies
        .filter((r) => !!r.schema)
        .map((r) => context.generateTypeFromRefableSchema(r.schema, [])))).join(" | ");
    if (body) {
        let doc = "";
        if (requestBodies[0].doc) {
            doc = generateDocs(requestBodies[0].doc);
        }
        definitions.push(`${doc}@body body: ${body}`);
    }
    return definitions;
}
function supportsOnlyJson(contentTypes) {
    return contentTypes.length === 1 && contentTypes[0] === "application/json";
}
//# sourceMappingURL=generate-operation.js.map