export type FileType = "yaml" | "json";
export type OpenAPIVersion = "3.0.0" | "3.1.0";
export type ExperimentalParameterExamplesStrategy = "data" | "serialized";
export interface OpenAPI3EmitterOptions {
    /**
     * If the content should be serialized as YAML or JSON.
     * @default yaml, it not specified infer from the `output-file` extension
     */
    "file-type"?: FileType;
    /**
     * Name of the output file.
     * Output file will interpolate the following values:
     *  - service-name: Name of the service
     *  - service-name-if-multiple: Name of the service if multiple
     *  - version: Version of the service if multiple
     *
     * @default `{service-name-if-multiple}.{version}.openapi.yaml` or `.json` if {@link OpenAPI3EmitterOptions["file-type"]} is `"json"`
     *
     * @example Single service no versioning
     *  - `openapi.yaml`
     *
     * @example Multiple services no versioning
     *  - `openapi.Org1.Service1.yaml`
     *  - `openapi.Org1.Service2.yaml`
     *
     * @example Single service with versioning
     *  - `openapi.v1.yaml`
     *  - `openapi.v2.yaml`
     *
     * @example Multiple service with versioning
     *  - `openapi.Org1.Service1.v1.yaml`
     *  - `openapi.Org1.Service1.v2.yaml`
     *  - `openapi.Org1.Service2.v1.0.yaml`
     *  - `openapi.Org1.Service2.v1.1.yaml`
     */
    "output-file"?: string;
    /**
     * Set the newline character for emitting files.
     * @default lf
     */
    "new-line"?: "crlf" | "lf";
    /**
     * Omit unreachable types.
     * By default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.
     */
    "omit-unreachable-types"?: boolean;
    /**
     * If the generated openapi types should have the `x-typespec-name` extension set with the name of the TypeSpec type that created it.
     * This extension is meant for debugging and should not be depended on.
     * @default "never"
     */
    "include-x-typespec-name"?: "inline-only" | "never";
    /**
     * How to handle safeint type. Options are:
     *  - `double-int`: Will produce `type: integer, format: double-int`
     *  - `int64`: Will produce `type: integer, format: int64`
     * @default "int64"
     */
    "safeint-strategy"?: "double-int" | "int64";
    /**
     * If true, then for models emitted as object schemas we default `additionalProperties` to false for
     * OpenAPI 3.0, and `unevaluatedProperties` to false for OpenAPI 3.1, if not explicitly specified elsewhere.
     * @default false
     */
    "seal-object-schemas"?: boolean;
    /**
     * Determines how to emit examples on parameters.
     *
     * Note: This is an experimental feature and may change in future versions.
     * @see https://spec.openapis.org/oas/v3.0.4.html#style-examples for parameter example serialization rules.
     * @see https://github.com/OAI/OpenAPI-Specification/discussions/4622 for discussion on handling parameter examples.
     */
    "experimental-parameter-examples"?: ExperimentalParameterExamplesStrategy;
}
export declare const $lib: import("@typespec/compiler").TypeSpecLibrary<{
    "oneof-union": {
        readonly default: "@oneOf decorator can only be used on a union or a model property which type is a union.";
    };
    "inconsistent-shared-route-request-visibility": {
        readonly default: "All operations with `@sharedRoutes` must have the same `@requestVisibility`.";
    };
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["value", "paramType"]>;
    };
    "invalid-style": {
        readonly default: import("@typespec/compiler").CallableMessage<["style", "paramType"]>;
        readonly optionalPath: import("@typespec/compiler").CallableMessage<["style", "paramType", "style"]>;
    };
    "path-reserved-expansion": {
        readonly default: "Reserved expansion of path parameter with '+' operator #{allowReserved: true} is not supported in OpenAPI3.";
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "empty-union": {
        readonly default: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "empty-enum": {
        readonly default: "Empty enums are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "enum-unique-type": {
        readonly default: "Enums are not supported unless all options are literals of the same type.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "invalid-model-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
    "xml-attribute-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "xml-unwrapped-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-component-fixed-field-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["value"]>;
    };
}, OpenAPI3EmitterOptions, never>;
export declare const createDiagnostic: <C extends "oneof-union" | "inconsistent-shared-route-request-visibility" | "invalid-server-variable" | "invalid-format" | "invalid-style" | "path-reserved-expansion" | "resource-namespace" | "path-query" | "duplicate-header" | "status-code-in-default-response" | "invalid-schema" | "union-null" | "empty-union" | "empty-enum" | "enum-unique-type" | "inline-cycle" | "unsupported-status-code-range" | "invalid-model-property" | "unsupported-auth" | "xml-attribute-invalid-property-type" | "xml-unwrapped-invalid-property-type" | "invalid-component-fixed-field-key", M extends keyof {
    "oneof-union": {
        readonly default: "@oneOf decorator can only be used on a union or a model property which type is a union.";
    };
    "inconsistent-shared-route-request-visibility": {
        readonly default: "All operations with `@sharedRoutes` must have the same `@requestVisibility`.";
    };
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["value", "paramType"]>;
    };
    "invalid-style": {
        readonly default: import("@typespec/compiler").CallableMessage<["style", "paramType"]>;
        readonly optionalPath: import("@typespec/compiler").CallableMessage<["style", "paramType", "style"]>;
    };
    "path-reserved-expansion": {
        readonly default: "Reserved expansion of path parameter with '+' operator #{allowReserved: true} is not supported in OpenAPI3.";
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "empty-union": {
        readonly default: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "empty-enum": {
        readonly default: "Empty enums are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "enum-unique-type": {
        readonly default: "Enums are not supported unless all options are literals of the same type.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "invalid-model-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
    "xml-attribute-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "xml-unwrapped-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-component-fixed-field-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["value"]>;
    };
}[C]>(diag: import("@typespec/compiler").DiagnosticReport<{
    "oneof-union": {
        readonly default: "@oneOf decorator can only be used on a union or a model property which type is a union.";
    };
    "inconsistent-shared-route-request-visibility": {
        readonly default: "All operations with `@sharedRoutes` must have the same `@requestVisibility`.";
    };
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["value", "paramType"]>;
    };
    "invalid-style": {
        readonly default: import("@typespec/compiler").CallableMessage<["style", "paramType"]>;
        readonly optionalPath: import("@typespec/compiler").CallableMessage<["style", "paramType", "style"]>;
    };
    "path-reserved-expansion": {
        readonly default: "Reserved expansion of path parameter with '+' operator #{allowReserved: true} is not supported in OpenAPI3.";
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "empty-union": {
        readonly default: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "empty-enum": {
        readonly default: "Empty enums are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "enum-unique-type": {
        readonly default: "Enums are not supported unless all options are literals of the same type.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "invalid-model-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
    "xml-attribute-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "xml-unwrapped-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-component-fixed-field-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["value"]>;
    };
}, C, M>) => import("@typespec/compiler").Diagnostic, reportDiagnostic: <C extends "oneof-union" | "inconsistent-shared-route-request-visibility" | "invalid-server-variable" | "invalid-format" | "invalid-style" | "path-reserved-expansion" | "resource-namespace" | "path-query" | "duplicate-header" | "status-code-in-default-response" | "invalid-schema" | "union-null" | "empty-union" | "empty-enum" | "enum-unique-type" | "inline-cycle" | "unsupported-status-code-range" | "invalid-model-property" | "unsupported-auth" | "xml-attribute-invalid-property-type" | "xml-unwrapped-invalid-property-type" | "invalid-component-fixed-field-key", M extends keyof {
    "oneof-union": {
        readonly default: "@oneOf decorator can only be used on a union or a model property which type is a union.";
    };
    "inconsistent-shared-route-request-visibility": {
        readonly default: "All operations with `@sharedRoutes` must have the same `@requestVisibility`.";
    };
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["value", "paramType"]>;
    };
    "invalid-style": {
        readonly default: import("@typespec/compiler").CallableMessage<["style", "paramType"]>;
        readonly optionalPath: import("@typespec/compiler").CallableMessage<["style", "paramType", "style"]>;
    };
    "path-reserved-expansion": {
        readonly default: "Reserved expansion of path parameter with '+' operator #{allowReserved: true} is not supported in OpenAPI3.";
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "empty-union": {
        readonly default: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "empty-enum": {
        readonly default: "Empty enums are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "enum-unique-type": {
        readonly default: "Enums are not supported unless all options are literals of the same type.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "invalid-model-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
    "xml-attribute-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "xml-unwrapped-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-component-fixed-field-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["value"]>;
    };
}[C]>(program: import("@typespec/compiler").Program, diag: import("@typespec/compiler").DiagnosticReport<{
    "oneof-union": {
        readonly default: "@oneOf decorator can only be used on a union or a model property which type is a union.";
    };
    "inconsistent-shared-route-request-visibility": {
        readonly default: "All operations with `@sharedRoutes` must have the same `@requestVisibility`.";
    };
    "invalid-server-variable": {
        readonly default: import("@typespec/compiler").CallableMessage<["propName"]>;
    };
    "invalid-format": {
        readonly default: import("@typespec/compiler").CallableMessage<["value", "paramType"]>;
    };
    "invalid-style": {
        readonly default: import("@typespec/compiler").CallableMessage<["style", "paramType"]>;
        readonly optionalPath: import("@typespec/compiler").CallableMessage<["style", "paramType", "style"]>;
    };
    "path-reserved-expansion": {
        readonly default: "Reserved expansion of path parameter with '+' operator #{allowReserved: true} is not supported in OpenAPI3.";
    };
    "resource-namespace": {
        readonly default: "Resource goes on namespace";
    };
    "path-query": {
        readonly default: "OpenAPI does not allow paths containing a query string.";
    };
    "duplicate-header": {
        readonly default: import("@typespec/compiler").CallableMessage<["header"]>;
    };
    "status-code-in-default-response": {
        readonly default: "a default response should not have an explicit status code";
    };
    "invalid-schema": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "union-null": {
        readonly default: "Cannot have a union containing only null types.";
    };
    "empty-union": {
        readonly default: "Empty unions are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "empty-enum": {
        readonly default: "Empty enums are not supported for OpenAPI v3 - enums must have at least one value.";
    };
    "enum-unique-type": {
        readonly default: "Enums are not supported unless all options are literals of the same type.";
    };
    "inline-cycle": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-status-code-range": {
        readonly default: import("@typespec/compiler").CallableMessage<["start", "end"]>;
    };
    "invalid-model-property": {
        readonly default: import("@typespec/compiler").CallableMessage<["type"]>;
    };
    "unsupported-auth": {
        readonly default: import("@typespec/compiler").CallableMessage<["authType"]>;
    };
    "xml-attribute-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "xml-unwrapped-invalid-property-type": {
        readonly default: import("@typespec/compiler").CallableMessage<["name"]>;
    };
    "invalid-component-fixed-field-key": {
        readonly default: import("@typespec/compiler").CallableMessage<["value"]>;
    };
}, C, M>) => void, createStateSymbol: (name: string) => symbol;
export type OpenAPILibrary = typeof $lib;
//# sourceMappingURL=lib.d.ts.map