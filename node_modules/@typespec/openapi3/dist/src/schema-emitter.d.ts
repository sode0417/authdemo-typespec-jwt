import { ArrayBuilder, AssetEmitter, Context, Declaration, EmitEntity, EmitterOutput, ObjectBuilder, Placeholder, ReferenceCycle, Scope, TypeEmitter } from "@typespec/asset-emitter";
import { BooleanLiteral, DiscriminatedUnion, Enum, EnumMember, IntrinsicScalarName, Model, ModelProperty, NumericLiteral, Program, Scalar, StringLiteral, StringTemplate, Tuple, Type, Union, UnionVariant } from "@typespec/compiler";
import { MetadataInfo } from "@typespec/http";
import { JsonSchemaModule } from "./json-schema.js";
import { OpenAPI3EmitterOptions } from "./lib.js";
import { ResolvedOpenAPI3EmitterOptions } from "./openapi.js";
import { OpenAPI3Schema, OpenAPI3SchemaProperty, OpenAPISchema3_1 } from "./types.js";
import { VisibilityUsageTracker } from "./visibility-usage.js";
import { XmlModule } from "./xml-module.js";
/**
 * Base OpenAPI3 schema emitter. Deals with emitting content of `components/schemas` section.
 */
export declare class OpenAPI3SchemaEmitterBase<Schema extends OpenAPI3Schema | OpenAPISchema3_1> extends TypeEmitter<Record<string, any>, OpenAPI3EmitterOptions> {
    #private;
    protected _metadataInfo: MetadataInfo;
    protected _visibilityUsage: VisibilityUsageTracker;
    protected _options: ResolvedOpenAPI3EmitterOptions;
    protected _jsonSchemaModule: JsonSchemaModule | undefined;
    protected _xmlModule: XmlModule | undefined;
    constructor(emitter: AssetEmitter<Record<string, any>, OpenAPI3EmitterOptions>, metadataInfo: MetadataInfo, visibilityUsage: VisibilityUsageTracker, options: ResolvedOpenAPI3EmitterOptions, optionalDependencies: {
        jsonSchemaModule?: JsonSchemaModule;
        xmlModule?: XmlModule;
    });
    modelDeclarationReferenceContext(model: Model, name: string): Context;
    modelLiteralReferenceContext(model: Model): Context;
    scalarDeclarationReferenceContext(scalar: Scalar, name: string): Context;
    enumDeclarationReferenceContext(en: Enum, name: string): Context;
    unionDeclarationReferenceContext(union: Union): Context;
    reduceContext(type: Type): Context;
    applyDiscriminator(type: Model, schema: Schema): void;
    shouldSealSchema(model: Model): boolean;
    applyModelIndexer(schema: ObjectBuilder<any>, model: Model): void;
    modelDeclaration(model: Model, _: string): EmitterOutput<object>;
    getContentType(): string;
    modelLiteral(model: Model): EmitterOutput<object>;
    modelInstantiation(model: Model, name: string | undefined): EmitterOutput<Record<string, any>>;
    unionInstantiation(union: Union, name: string): EmitterOutput<Record<string, any>>;
    arrayDeclaration(array: Model, name: string, elementType: Type): EmitterOutput<object>;
    arrayDeclarationReferenceContext(array: Model, name: string, elementType: Type): Context;
    arrayLiteral(array: Model, elementType: Type): EmitterOutput<object>;
    arrayLiteralReferenceContext(array: Model, elementType: Type): Context;
    modelProperties(model: Model): EmitterOutput<Record<string, OpenAPI3SchemaProperty>>;
    getRawBinarySchema(): Schema;
    modelPropertyLiteral(prop: ModelProperty): EmitterOutput<object>;
    booleanLiteral(boolean: BooleanLiteral): EmitterOutput<object>;
    stringLiteral(string: StringLiteral): EmitterOutput<object>;
    stringTemplate(string: StringTemplate): EmitterOutput<object>;
    numericLiteral(number: NumericLiteral): EmitterOutput<object>;
    enumDeclaration(en: Enum, name: string): EmitterOutput<object>;
    enumSchema(en: Enum): Schema;
    enumMember(member: EnumMember): EmitterOutput<Record<string, any>>;
    enumMemberReference(member: EnumMember): EmitterOutput<Record<string, any>>;
    unionDeclaration(union: Union, name: string): EmitterOutput<object>;
    unionSchema(union: Union): ObjectBuilder<Schema>;
    discriminatedUnion(union: DiscriminatedUnion): ObjectBuilder<Schema>;
    getDiscriminatorMapping(variants: Map<string, Type>): Record<string, string>;
    unionLiteral(union: Union): EmitterOutput<object>;
    unionVariants(union: Union): EmitterOutput<object>;
    unionVariant(variant: UnionVariant): EmitterOutput<object>;
    modelPropertyReference(prop: ModelProperty): EmitterOutput<object>;
    reference(targetDeclaration: Declaration<Record<string, unknown>>, pathUp: Scope<Record<string, unknown>>[], pathDown: Scope<Record<string, unknown>>[], commonScope: Scope<Record<string, unknown>> | null): object | EmitEntity<Record<string, unknown>>;
    circularReference(target: EmitEntity<Record<string, any>>, scope: Scope<Record<string, any>> | undefined, cycle: ReferenceCycle): Record<string, any> | EmitEntity<Record<string, any>>;
    scalarDeclaration(scalar: Scalar, name: string): EmitterOutput<Schema>;
    scalarInstantiation(scalar: Scalar, name: string | undefined): EmitterOutput<Record<string, any>>;
    tupleLiteral(tuple: Tuple): EmitterOutput<Record<string, any>>;
    getSchemaForStdScalars(scalar: Scalar & {
        name: IntrinsicScalarName;
    }): Schema;
    applyCustomConstraints(type: Scalar | Model | ModelProperty | Union | Enum, target: Schema, refSchema?: Schema): void;
    applyConstraints(type: Scalar | Model | ModelProperty | Union | Enum, original: Schema, refSchema?: Schema): ObjectBuilder<Schema>;
    applyXml(type: Scalar | Model | ModelProperty | Union | Enum, schema: Schema, refSchema?: Schema): void;
    applyEncoding(typespecType: Scalar | ModelProperty, target: Schema | Placeholder<Schema>): Schema;
    programContext(program: Program): Context;
}
export declare const Builders: {
    readonly array: <T>(items: T[]) => ArrayBuilder<T>;
    readonly object: <T extends Record<string, unknown>>(obj: T) => ObjectBuilder<T[string]>;
};
//# sourceMappingURL=schema-emitter.d.ts.map